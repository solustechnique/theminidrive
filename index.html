<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Freign Mini Drive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    body { margin:0; background:#000; color:#fff; font-family:"IBM Plex Mono", monospace; }
    .wrap { max-width:1100px; margin:0 auto; padding:18px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .bar { border-bottom:1px solid #222; padding-bottom:12px; margin-bottom:12px; }
    input, button, textarea { font:inherit; color:#fff; background:transparent; border:1px solid #333; padding:6px 10px; outline:none; }
    button:hover { border-color:#fff; cursor:pointer; }
    .grid { display:grid; grid-template-columns:1fr 1fr; gap:16px; }
    .block { border:1px solid #222; padding:10px; }
    .list { display:flex; flex-direction:column; gap:6px; }
    .item { display:flex; justify-content:space-between; border:1px solid #222; padding:6px; }
    .item:hover { border-color:#fff; }
    .chip { border:1px solid #333; padding:2px 6px; }
    textarea { width:100%; min-height:160px; }
    iframe { width:100%; height:320px; border:1px solid #333; background:#111; }
    img, video { max-width:100%; border:1px solid #333; background:#111; }
    .danger { border-color:#c00; color:#fbb; }
    .success { border-color:#0c0; color:#bfb; }
    .status { font-size:12px; color:#888; min-height:18px; }
    .spacer { flex:1; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="bar row">
      <label>Drive:</label>
      <input id="driveCode" placeholder="e.g. F92HD" />
      <button id="loadDrive">Open</button>
      <span id="driveStatus" class="status"></span>
      <div class="spacer"></div>
      <input id="fileInput" type="file" multiple />
      <button id="uploadBtn">Upload</button>
      <button id="refreshBtn">Refresh</button>
      <button id="qrBtn">Copy drive link</button>
    </div>
    <div class="grid">
      <div class="block">
        <h3>Files</h3>
        <div id="filesList" class="list"></div>
        <div class="row" style="margin-top:8px">
          <span id="listStatus" class="status"></span>
          <div class="spacer"></div>
          <button id="clearDriveBtn" class="danger">Clear drive</button>
        </div>
      </div>
      <div class="block">
        <h3>Preview / Editor</h3>
        <div class="row">
          <span id="currentFileName" class="chip"></span>
          <div class="spacer"></div>
          <button id="downloadBtn">Download</button>
          <button id="copyUrlBtn">Copy URL</button>
          <button id="deleteBtn" class="danger">Delete</button>
          <button id="runBtn">Run HTML</button>
          <button id="saveBtn" class="success">Save</button>
        </div>
        <div id="previewArea" style="margin-top:10px"></div>
        <div id="editorArea" style="margin-top:10px; display:none">
          <textarea id="editor" placeholder="Edit text or HTML here"></textarea>
        </div>
        <div style="margin-top:10px">
          <span id="previewStatus" class="status"></span>
        </div>
      </div>
    </div>
  </div>
  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    const SUPABASE_URL = "https://uwxohdtmpmbnnhfjcprd.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV3eG9oZHRtcG1ibm5oZmpjcHJkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk4MjI0OTEsImV4cCI6MjA3NTM5ODQ5MX0.9qXm4XvQSYkjxBsrbCotI5k0w-JXD-MoDlGlE_8fKY8";
    const BUCKET = "drives";
    const { createClient } = supabase;
    const sb = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    let currentDrive = "";
    let currentFile = null;
    let currentList = [];
    const driveInput = document.getElementById("driveCode");
    const driveStatus = document.getElementById("driveStatus");
    const filesList = document.getElementById("filesList");
    const listStatus = document.getElementById("listStatus");
    const previewArea = document.getElementById("previewArea");
    const previewStatus = document.getElementById("previewStatus");
    const editorArea = document.getElementById("editorArea");
    const editor = document.getElementById("editor");
    const currentFileNameChip = document.getElementById("currentFileName");
    function qsParam(key) { const u = new URL(window.location.href); return u.searchParams.get(key) || ""; }
    function setStatus(el, msg) { el.textContent = msg || ""; }
    function mimeFromName(name) {
      const ext = (name.split(".").pop() || "").toLowerCase();
      const m = { png:"image/png", jpg:"image/jpeg", jpeg:"image/jpeg", gif:"image/gif", webp:"image/webp", svg:"image/svg+xml", ico:"image/x-icon", mp4:"video/mp4", webm:"video/webm", txt:"text/plain", md:"text/markdown", json:"application/json", html:"text/html", htm:"text/html", css:"text/css", js:"application/javascript", pdf:"application/pdf" };
      return m[ext] || "application/octet-stream";
    }
    function isTextLike(name, type) { const mt = type || mimeFromName(name); return mt.startsWith("text/") || mt === "application/json" || mt === "application/javascript"; }
    function isHtml(name, type) { const mt = type || mimeFromName(name); return mt === "text/html"; }
    function pathFor(drive, name) { return `${drive}/${name}`; }
    function publicUrl(drive, name) { const { data } = sb.storage.from(BUCKET).getPublicUrl(pathFor(drive, name)); return data.publicUrl; }
    async function openDrive(code) {
      currentDrive = (code || "").trim();
      if (!currentDrive) { setStatus(driveStatus, "Enter a drive code"); return; }
      setStatus(driveStatus, `Opened ${currentDrive}`);
      const u = new URL(window.location.href); u.searchParams.set("d", currentDrive); history.replaceState(null, "", u.toString());
      await refreshList();
    }
    async function refreshList() {
      filesList.innerHTML = "";
      setStatus(listStatus, "Loading...");
      const { data, error } = await sb.storage.from(BUCKET).list(currentDrive, { limit: 1000 });
      if (error) { setStatus(listStatus, `Error: ${error.message}`); return; }
      currentList = data || [];
      setStatus(listStatus, `${currentList.length} file(s)`);
      currentList.sort((a,b) => (a.name > b.name ? 1 : -1));
      for (const f of currentList) {
        const row = document.createElement("div"); row.className = "item";
        const left = document.createElement("div"); left.textContent = f.name;
        const right = document.createElement("div"); right.className = "row";
        const openBtn = document.createElement("button"); openBtn.textContent = "Open"; openBtn.onclick = () => selectFile(f.name);
        const urlBtn = document.createElement("button"); urlBtn.textContent = "URL"; urlBtn.onclick = () => { const url = publicUrl(currentDrive, f.name); navigator.clipboard.writeText(url); setStatus(previewStatus, "Copied public URL"); };
        right.appendChild(openBtn); right.appendChild(urlBtn);
        row.appendChild(left); row.appendChild(right);
        filesList.appendChild(row);
      }
    }
    async function selectFile(name) {
      currentFile = { name, path: pathFor(currentDrive, name), type: mimeFromName(name) };
      currentFileNameChip.textContent = name;
      previewArea.innerHTML = "";
      editorArea.style.display = "none";
      setStatus(previewStatus, "Loading...");
      const { data, error } = await sb.storage.from(BUCKET).download(currentFile.path);
      if (error) { setStatus(previewStatus, `Error: ${error.message}`); return; }
      const blob = data;
      const type = currentFile.type;
      if (type.startsWith("image/")) {
        const img = document.createElement("img"); img.src = URL.createObjectURL(blob); previewArea.appendChild(img); setStatus(previewStatus, "");
      } else if (type.startsWith("video/")) {
        const vid = document.createElement("video"); vid.controls = true; vid.src = URL.createObjectURL(blob); previewArea.appendChild(vid); setStatus(previewStatus, "");
      } else if (isHtml(name, type)) {
        const text = await blob.text(); editor.value = text; editorArea.style.display = "block"; setStatus(previewStatus, "HTML loaded");
      } else if (isTextLike(name, type)) {
        const text = await blob.text(); editor.value = text; editorArea.style.display = "block"; setStatus(previewStatus, "Text loaded");
      } else if (type === "application/pdf") {
        const iframe = document.createElement("iframe"); iframe.src = URL.createObjectURL(blob); previewArea.appendChild(iframe); setStatus(previewStatus, "");
      } else {
        const link = document.createElement("a"); link.href = URL.createObjectURL(blob); link.download = name; link.textContent = "Download file"; previewArea.appendChild(link); setStatus(previewStatus, "Ready to download");
      }
    }
    async function uploadSelected() {
      if (!currentDrive) { setStatus(driveStatus, "Open a drive first"); return; }
      const input = document.getElementById("fileInput");
      const files = Array.from(input.files || []);
      if (!files.length) { setStatus(listStatus, "Choose files to upload"); return; }
      setStatus(listStatus, `Uploading ${files.length} file(s)...`);
      for (const file of files) {
        const path = pathFor(currentDrive, file.name);
        const contentType = file.type || mimeFromName(file.name);
        const { error } = await sb.storage.from(BUCKET).upload(path, file, { upsert: true, contentType });
        if (error) { setStatus(listStatus, `Error: ${error.message}`); return; }
      }
      setStatus(listStatus, "Upload complete");
      input.value = "";
      await refreshList();
    }
    async function saveCurrent() {
      if (!currentFile) { setStatus(previewStatus, "No file selected"); return; }
      const content = editor.value || "";
      const type = isHtml(currentFile.name, currentFile.type) ? "text/html" : "text/plain";
      const blob = new Blob([content], { type });
      const { error } = await sb.storage.from(BUCKET).upload(currentFile.path, blob, { upsert: true, contentType: type });
      if (error) { setStatus(previewStatus, `Error: ${error.message}`); return; }
      setStatus(previewStatus, "Saved");
      await refreshList();
    }
    function runHtml() {
      if (!currentFile) { setStatus(previewStatus, "No file selected"); return; }
      const content = editor.value || "";
      const blob = new Blob([content], { type: "text/html" });
      const url = URL.createObjectURL(blob);
      previewArea.innerHTML = "";
      const frame = document.createElement("iframe"); frame.src = url; previewArea.appendChild(frame);
      setStatus(previewStatus, "Running preview");
    }
    async function deleteCurrent() {
      if (!currentFile) { setStatus(previewStatus, "No file selected"); return; }
      const ok = confirm(`Delete ${currentFile.name}?`); if (!ok) return;
      const { error } = await sb.storage.from(BUCKET).remove([currentFile.path]);
      if (error) { setStatus(previewStatus, `Error: ${error.message}`); return; }
      setStatus(previewStatus, "Deleted");
      currentFile = null; currentFileNameChip.textContent = ""; previewArea.innerHTML = ""; editorArea.style.display = "none";
      await refreshList();
    }
    async function clearDrive() {
      if (!currentDrive) return;
      const ok = confirm(`Delete ALL files in ${currentDrive}?`); if (!ok) return;
      const { data, error } = await sb.storage.from(BUCKET).list(currentDrive, { limit: 1000 });
      if (error) { setStatus(listStatus, `Error: ${error.message}`); return; }
      const paths = (data || []).map(f => pathFor(currentDrive, f.name));
      if (!paths.length) { setStatus(listStatus, "Drive is empty"); return; }
      const res = await sb.storage.from(BUCKET).remove(paths);
      if (res.error) { setStatus(listStatus, `Error: ${res.error.message}`); return; }
      setStatus(listStatus, "Drive cleared");
      await refreshList();
    }
    async function downloadCurrent() {
      if (!currentFile) { setStatus(previewStatus, "No file selected"); return; }
      const { data, error } = await sb.storage.from(BUCKET).download(currentFile.path);
      if (error) { setStatus(previewStatus, `Error: ${error.message}`); return; }
      const url = URL.createObjectURL(data);
      const a = document.createElement("a"); a.href = url; a.download = currentFile.name; a.click();
      setStatus(previewStatus, "Downloaded");
    }
    async function copyCurrentUrl() {
      if (!currentFile) { setStatus(previewStatus, "No file selected"); return; }
      const url = publicUrl(currentDrive, currentFile.name);
      await navigator.clipboard.writeText(url);
      setStatus(previewStatus, "Copied public URL");
    }
    function copyDriveLink() {
      const u = new URL(window.location.href);
      const code = currentDrive || (driveInput.value || "").trim();
      if (!code) { setStatus(driveStatus, "Enter a drive code"); return; }
      u.searchParams.set("d", code);
      navigator.clipboard.writeText(u.toString());
      setStatus(driveStatus, "Drive link copied");
    }
    document.getElementById("loadDrive").onclick = () => openDrive(driveInput.value);
    document.getElementById("uploadBtn").onclick = uploadSelected;
    document.getElementById("refreshBtn").onclick = refreshList;
    document.getElementById("qrBtn").onclick = copyDriveLink;
    document.getElementById("saveBtn").onclick = saveCurrent;
    document.getElementById("runBtn").onclick = runHtml;
    document.getElementById("deleteBtn").onclick = deleteCurrent;
    document.getElementById("downloadBtn").onclick = downloadCurrent;
    document.getElementById("copyUrlBtn").onclick = copyCurrentUrl;
    document.getElementById("clearDriveBtn").onclick = clearDrive;
    (function init() { const d = qsParam("d"); if (d) { driveInput.value = d; openDrive(d); } })();
  </script>
</body>
</html>
